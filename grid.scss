@import "./utilities/map";
@import "./utilities/strip-unit";
@import "./utilities/highlight-helper";

// =============================================================================
// Grid
// =============================================================================

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
@mixin grid(
    $nested: false
) {
    display: flex;
    position: relative;
    flex-direction: row;
    flex-wrap: wrap;
    align-items: stretch;

    @if($vertical-gutters) {
        @include grid-vertical-margins($top: -1);
        
        & > * {
            @include grid-vertical-margins($top: 1);
        }
    }

    @if($nested) {
        @if(is-valid-property-map($horizontal-gutters)) {
            @include fluid-property-map(
                $property: "margin-left",
                $values: $horizontal-gutters,
                $multiplier: -0.5
            );
            @include fluid-property-map(
                $property: "margin-right",
                $values: $horizontal-gutters,
                $multiplier: -0.5
            );
        }
    } @else {
        @if(is-valid-property-map($grid-padding-left)) {
            @include fluid-property-map(
                $property: "padding-left",
                $values: $grid-padding-left
            );
        }

        @if(is-valid-property-map($grid-padding-right)) {
            @include fluid-property-map(
                $property: "padding-right",
                $values: $grid-padding-right
            );
        }
    }
    
    @if($nested) {
        @include highlight-helper('Nested Grid', $colour-nested-grids, '.show-containers');
    } @else {
        @include highlight-helper('Grid', $colour-grids, '.show-containers') {
            @include grid-vertical-margins($top: 1);
        }
    }
}

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
@mixin grid-column(
    $width: null,
    $margin-left: null,
    $margin-right: null,
    $padding-left: 0.5,
    $padding-right: 0.5,
    $padding-top: null,
    $padding-bottom: null,
    $spill-direction: null
) {
    position: relative;
    min-width: 0;

    // Width
    @if($width != null) {
        @include grid-column-width($width);
    }

    @if($horizontal-gutters != null) {

        // Gutters
        @include grid-column-padding($padding-left: $padding-left, $padding-right: $padding-right);

        // Margins
        @if($spill-direction != null and ($margin-left != null or $margin-right != null)) {
            @error('Margins and spill-direction cannot be set simultaneously.');
        }

        // @include grid-column-vertical-margins($top: $margin-top, $bottom: $margin-bottom);
        @include grid-column-horizontal-margins($left: $margin-left, $right: $margin-right);
    }

    @if($vertical-gutters != null) {
        @include grid-column-padding($padding-top: $padding-top, $padding-bottom: $padding-bottom);
    }
    
    // Spill
    @if $spill-direction != null {
        @include grid-column-spill($spill-direction);
    }

    // Helpers
    @include highlight-helper('grid-column', $colour-columns, '.show-columns');

    & > * {
        @include highlight-helper('grid-column > *', $colour-blocks, '.show-block-children');
    }
}

/*
 * This mixin applies a width to a column based on a unitless fraction. It's designed to be agnostic to the number of
 * columns in the grid system you're using, so you can express your column's width as 4/12, 8/24, 1/2, 1/8 ...or 1/7 if you enjoy headaches.
 * NOTE: This mixin should not be used directly. Instead, access it by passing the above values to the grid-column mixin.
 */

@mixin grid-column-width($width: null) {
    @if(is-valid-property-map($width)) {
        $width: map-strip-unit($width);
        $width: map-percentage($width);
        @include property-map('width', $width);
    } @else if type-of($width) == "number" {
        width: percentage($width);
    } @else {
        @error("$width must be either a number or a valid property map.");
    }
}

/*
 * This mixin applies margins to a column based on a unitless fraction.
 * A parameter of $side: left and $width: 1/4, for example, would push your column to the 
 * NOTE: This mixin should not be used directly. Instead, access it by passing the above values to the grid-column mixin.
 */

 @mixin grid-column-horizontal-margins($left: null, $right: null) {
    $margins: (left: $left, right: $right);

    @each $side, $amount in $margins {
        @if(is-valid-property-map($amount)) {
            $amount: map-strip-unit($amount);
            $amount: map-percentage($amount);
            @include property-map('margin-#{$side}', $amount);
        } @else if type-of($amount) == "number" {
            margin-#{$side}: percentage($amount);
        } @else if $amount != null {
            @debug('A horizontal margin for a column must be a property map of fractions, or a number.');
        }
    }
}

@mixin grid-vertical-margins($top: null, $bottom: null) {
    $margins: (top: $top, bottom: $bottom);

    @each $side, $amount in $margins {
        @if type-of($amount) == "number" {
            @include fluid-property-map($property: 'margin-#{$side}', $values: $vertical-gutters, $multiplier: $amount);
        } @else if $amount != null {
            @debug('A vertical margin for a column must be a unitless number.');
        }
    }
}

/*
 * This mixin applies top, bottom, left and right gutters to a column based on a unitless multiplier.
 * A parameter of $padding-top: 2, for example, would give the column a top-padding that is
 * 2 x the basic $gutter property map, set in your variables file.
 * NOTE: This mixin should not be used directly. Instead, access it by passing the above values to the grid-column mixin.
 */

@mixin grid-column-padding($padding-left: 0.5, $padding-right: 0.5, $padding-top: 0, $padding-bottom: 0) {
    @if($padding-top != none) {
        @include fluid-property-map($property: padding-top, $values: $vertical-gutters, $multiplier: $padding-top);
    }

    @if($padding-bottom != none) {
        @include fluid-property-map($property: padding-bottom, $values: $vertical-gutters, $multiplier: $padding-bottom);
    }

    @if($padding-left != none) {
        @include fluid-property-map($property: padding-left, $values: $horizontal-gutters, $multiplier: $padding-left);
    }

    @if($padding-right != none) {
        @include fluid-property-map($property: padding-right, $values: $horizontal-gutters, $multiplier: $padding-right);
    }
}

/*
 * This mixin 'spills' a left-most or right-most column to the edge of the viewport, enabling you to have an inset grid system while still being able to reach the edges of the viewport with your blocks. Accepts either 'left' or 'right'.
 * NOTE: This mixin should not be used directly. Instead, access it by passing the above values to the grid-column mixin.
 */
 @mixin grid-column-spill($direction) {
    @if ($direction != left and $direction != right and $direction != none) {
        @error('Invalid spill direction value: #{$direction}');
    }

    @if $direction == left and not is-valid-property-map($grid-padding-left) {
        @error('$grid-padding-left must be set in order to spill a column to the left.');
    }

    @if $direction == right and not is-valid-property-map($grid-padding-right) {
        @error('$grid-padding-right must be set in order to spill a column to the right.');
    }

    $opposite: null;
    
    @if($direction == left) {
        $opposite: right;
    } @else if($direction == right) {
        $opposite: left;
    } @else if($direction == top) {
        $opposite: bottom;
    } @else if($direction == bottom) {
        $opposite: top;
    } @else {
        @error('Invalid direction: #{$direction}');
    }

    $padding: if($direction == left, $grid-padding-left, $grid-padding-right);
    $distance: $padding;

    @if($direction != none) {
        @include fluid-property-map(
            $property: #{$direction},
            $values: $distance,
            $multiplier: -1
        );
    
        > * {
            @include fluid-property-map(
                "margin-#{$opposite}",
                $values: $distance,
                $multiplier: -1
            );
        }
    } @else {
        #{$direction}: 0;
        margin-#{$opposite}: 0;
    }
}

@mixin grid-column-spill-reverse($direction) {
    @if ($direction != left and $direction != right) {
        @error('Invalid spill direction value: #{$direction}');
    }

    $distance: if($direction == left, $grid-padding-left, $grid-padding-right);
 
    @if($direction == left) {
        @include fluid-property-map('padding-left', $distance);
    } @else if($direction == right) {
        @include fluid-property-map('padding-right', $distance);
    }
}

@mixin grid-overlay {
    @include grid;

    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;

    visibility: hidden;

    width: 100%; // Prevents collapse when flex parent

    html.show-grid & {
        visibility: visible;
    }

    .show-containers &:after {
        display: none !important;
    }
    
    &__column {
        @include grid-column(
            $width: 1 / $overlay-columns
        );
    }

    &__column:before {
        display: block;
        position: absolute;
        content: '';
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        border: 0.5px solid $colour-column-overlay;
    }

    &__column {
        .show-block-children & > *:after,
        .show-columns &:after {
            display: none !important;
        }
    }

    &__column > div {
        display: block;
        content: "";
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100vh;
        background-color: $colour-column-overlay;
    }

    &__column:nth-child(n + $overlay-columns) {
        display: none;
    }
}

// Validate variables

@if(not map-keys-correspond-to-keys-in-other-map($grid-padding-left, $breakpoints)) {
    @error('The breakpoints in $grid-padding-left do not all correspond to breakpoints in $breakpoints.');
}

@if(not map-keys-correspond-to-keys-in-other-map($grid-padding-right, $breakpoints)) {
    @error('The breakpoints in $grid-padding-right do not all correspond to breakpoints in $breakpoints.');
}

@if(not maps-have-same-keys($grid-padding-left, $grid-padding-right)) {
    @error('The breakpoint IDs in $grid-padding-left and $grid-padding-right do not match.');
}