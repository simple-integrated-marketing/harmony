@import "./utilities/map";
@import "./utilities/strip-unit";

// =============================================================================
// Grid
// =============================================================================

// TODO column margins broken

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
@mixin grid(
    $column-width: 1,
    $horizontal-gutters: $horizontal-gutters,
    $vertical-gutters: $vertical-gutters,
    $nested: false
) {
    display: flex;
    position: relative;    
    width: 100%; // Prevents collapse when flex parent
    flex-direction: row;
    flex-wrap: wrap;

    $negative-horizontal-gutters: map-multiply($horizontal-gutters, -0.5);
    
    @if($nested) {
        @include grid-container-padding($left: $negative-horizontal-gutters, $right: $negative-horizontal-gutters);
    } @else {
        @include grid-container-padding($left: $grid-padding-left, $right: $grid-padding-left);
    }

    // &__row {
    //     @include grid-row(
    //         $column-width: $column-width
    //     );
    // }
    
    // Apply default column widths as a convenience function for straightforward use cases, where all columns are the same width.
    &__column {
        @include grid-column(
            $width: $column-width,
            $horizontal-gutters: $horizontal-gutters,
            $vertical-gutters: $vertical-gutters
        );
    }
}

@mixin grid-container-padding($left: $grid-padding-left, $right: $grid-padding-right) {
    @if (is-valid-property-map($left)) {
        @include fluid-property-map(
            $property: "padding-left",
            $values: $left
        );
    }

    @if (is-valid-property-map($right)) {
        @include fluid-property-map(
            $property: "padding-right",
            $values: $right
        );
    }

    @include grid-gutter($side: top, $multiplier: -0.5);
    @include grid-gutter($side: bottom, $multiplier: 0.5);
}

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
// @mixin grid-row(
//     $column-width: none,
//     $nested: false
// ) {
//     display: flex;
//     position: relative;
//     flex-direction: row;
//     flex-wrap: wrap;

//     @if(is-valid-property-map($vertical-gutters)) {
//         // @include grid-gutter($side: top, $multiplier: -1);
//         // @include grid-gutter($side: bottom, $multiplier: 1);
//     }

//     @if($nested) {
//         @include grid-gutter($side: top, $multiplier: -0.5);
//         @include grid-gutter($side: bottom, $multiplier: 0.5);
//         @include grid-gutter($side: left, $multiplier: -0.5);
//         @include grid-gutter($side: right, $multiplier: -0.5);
//     }
// }

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
@mixin grid-column(
    $width: none,
    $spill-direction: none,
    $margin-left: none,
    $margin-right: none,
    $horizontal-gutters: $horizontal-gutters,
    $vertical-gutters: $vertical-gutters
) {
    position: relative;
    min-width: 0;

    // Width
    @if($width == none) {
        // Do nothing
    }
    @else if(is-valid-property-map($width)) {
        $width: map-strip-unit($width);
        $width: map-percentage($width);
        @include property-map('width', $width);
    } @else if type-of($width) == "number" {
        width: percentage($width);
    } @else {
        @debug('Column width must be a map or a number.');
    }

    // Horizontal gutters
    @if (is-valid-property-map($horizontal-gutters)) {
        @include grid-gutter(
            $side: left,
            $multiplier: 0.5
        );
        @include grid-gutter(
            $side: right,
            $multiplier: 0.5
        );
    }

    // Vertical gutters
    @if (is-valid-property-map($vertical-gutters)) {
        @include fluid-property-map(
            $property: 'padding-top',
            $values: $vertical-gutters,
            $multiplier: 0.5
        );

        @include fluid-property-map(
            $property: 'padding-bottom',
            $values: $vertical-gutters,
            $multiplier: 0.5
        );
    }

    // Spill
    @if $spill-direction != none {
        @include grid-column-spill($spill-direction);
    }
    
    // Margin left
    @if ($margin-left != none) {
        @include grid-column-margin(left, $margin-left);
    }

    // Margin right
    @if ($margin-right != none) {
        @include grid-column-margin(right, $margin-right);
    }

    .show-columns & {
        box-shadow: inset 0px 0px 0px 4000px $colour-columns;
    }

    .show-block-children & > * {
        box-shadow: inset 0px 0px 0px 4000px $colour-blocks;
    }
}

@mixin grid-column-margin($side, $width) {
    @if(is-valid-property-map($width)) {
        $width: map-strip-unit($width);
        $width: map-percentage($width);
        @include property-map('margin-#{$side}', $width);
    } @else if type-of($width) == "number" {
        margin-#{$side}: percentage($width);
    } @else {
        @debug('Column margin width must be a map or a number.');
    }
}

/*
 * Add a gutter to a chosen size of an element.
 * This forms the core of the mixins below.
 *
 * Usage:
 * @include grid-gutter($side: top, $multiplier: 1);
 */
@mixin grid-gutter($side, $multiplier: 0.5) {
    $values: null;
    
    @if($side == 'left' or $side == 'right') {
        $values: $horizontal-gutters;
    } @else if($side == 'top' or $side == 'bottom') {
        $values: $vertical-gutters;
    }

    @if (not is-valid-property-map($values)) {
        @error ('Grid gutters must be a map.');
    }

    $padding-or-margin: if($multiplier < 0, "margin", "padding");

    $property: "#{$padding-or-margin}-#{$side}";

    $values: map-multiply($values, $multiplier);

    @include fluid-property-map(
        $property: $property,
        $values: $values
    );
}

/*
 * Short description goes here.
 *
 * Usage:
 * @include ...
 */
@mixin grid-column-spill($direction) {
    @if ($direction != left and $direction != right) {
        @error('Invalid spill direction value: #{$direction}');
    }

    @if $direction == left and not is-valid-property-map($grid-padding-left) {
        @error('$grid-padding-left must be set in order to spill a column to the left.');
    }

    @if $direction == right and not is-valid-property-map($grid-padding-right) {
        @error('$grid-padding-right must be set in order to spill a column to the right.');
    }

    $opposite: get-opposite-direction($direction);
    $padding: if($direction == left, $grid-padding-left, $grid-padding-right);
    $distance: $padding;

    @include fluid-property-map(
        $property: #{$direction},
        $values: $distance,
        $multiplier: -1
    );

    > * {
        @include fluid-property-map(
            "margin-#{$opposite}",
            $values: $distance,
            $multiplier: -1
        );
    }
}

@function get-opposite-direction($direction) {
    @if($direction == left) {
        @return right;
    } @else if($direction == right) {
        @return left;
    } @else if($direction == top) {
        @return bottom;
    } @else if($direction == bottom) {
        @return top;
    } @else {
        @error('Invalid direction: #{$direction}');
    }
}

@mixin grid-column-spill-reverse($direction) {
    @if ($direction != left and $direction != right) {
        @error('Invalid spill direction value: #{$direction}');
    }

    $distance: if($direction == left, $grid-padding-left, $grid-padding-right);
    $gutters: map-multiply($horizontal-gutters, 0.5);
 
    @if($direction == left) {
        @include fluid-property-map('padding-left', $distance);
    } @else if($direction == right) {
        @include fluid-property-map('padding-right', $distance);
    }
}

@mixin grid-overlay {
    @include grid($column-width: 1 / $overlay-columns);

    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;

    visibility: hidden;

    html.show-grid & {
        visibility: visible;
    }

    &__column:before {
        display: block;
        position: absolute;
        content: '';
        top: 0;
        left: -0.5px;
        bottom: 0;
        width: 1px;
        background-color: $colour-column-overlay;
    }

    &__column:nth-child(#{$overlay-columns}):after {
        display: block;
        position: absolute;
        content: '';
        top: 0;
        right: -0.5px;
        bottom: 0;
        width: 1px;
        background-color: $colour-column-overlay;
    }

    &__column {
        .show-block-children & > div  {
            box-shadow: none !important;
        }

        .show-columns &  {
            box-shadow: none !important;
        }
    }

    &__column > div {
        display: block;
        content: "";
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100vh;
        background-color: $colour-column-overlay;
    }

    &__column:nth-child(n + $overlay-columns) {
        display: none;
    }
}

@mixin grid-column-to-property($property, $width) {
    $widths: ();

    @each $key, $left-value in $grid-padding-left {
        $right-value: map-get($grid-padding-right, $key);
        $breakpoint: map-get($breakpoints, $key);
        $calculated-width: ($breakpoint - $left-value - $right-value) * $width;

        $widths: map-merge($widths, ($key: $calculated-width));
    }

    @include fluid-property-map($property, $widths);
}

// Validate variables

@if(not map-keys-correspond-to-keys-in-other-map($grid-padding-left, $breakpoints)) {
    @error('The breakpoints in $grid-padding-left do not all correspond to breakpoints in $breakpoints.');
}

@if(not map-keys-correspond-to-keys-in-other-map($grid-padding-right, $breakpoints)) {
    @error('The breakpoints in $grid-padding-right do not all correspond to breakpoints in $breakpoints.');
}

@if(not maps-have-same-keys($grid-padding-left, $grid-padding-right)) {
    @error('The breakpoint IDs in $grid-padding-left and $grid-padding-left do not match.');
}

@if(not maps-have-same-keys($grid-padding-left, $horizontal-gutters)) {
    @error('The breakpoint IDs in $grid-padding-left and $horizontal-gutters do not match.');
}
